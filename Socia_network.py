"""
Course  : CMPSC 131, Fall 2024
File    : final_project.py 
Name    : Amogh Krishna Namuduri

GitHub User:   AmoghNamuduri

Collaboration Statement: I worked on the project all by myself . I did not collaborate with anyone on this assignment.
"""

# Error code constants
ERROR_DUPLICATE_USER = 0
ERROR_FAILED_AUTHENTICATION = 1
ERROR_FRIEND_ALREADY_FOUND = 2
ERROR_FRIEND_NOT_FOUND = 3
ERROR_USER_NOT_FOUND = 4
ERROR_MESSAGE = {ERROR_DUPLICATE_USER: "ERROR: found duplicate user.", 
                ERROR_FAILED_AUTHENTICATION: "ERROR: authentication failed.", 
                ERROR_FRIEND_ALREADY_FOUND: "ERROR: friendship already exists.", 
                ERROR_FRIEND_NOT_FOUND: "ERROR: friendship does not exist.", 
                ERROR_USER_NOT_FOUND: "ERROR: user does not exist in the social network."}
    

def error_to_string(error_code: int) -> str:
    """
        Provides a descriptive error message

        Args:
            error_code (int): error code generated by a function
        
        Returns:
            (str) Explanation of the error code
    """
    if error_code in ERROR_MESSAGE:
        return ERROR_MESSAGE[error_code]
    else:
        return "INVALID ERROR CODE"

################################################################################

#- YOUR CODE STARTS HERE  (TODO) 

import random 

def generate_key()->int:

    """
    Generate a key between 1 and 26, and returns the same key due to the fixed key

    Returns:
        int: It returns the same key every time it is called
    """

    random.seed(131)
    rand_int = random.randint(1,26)
    return rand_int


def encrypt_password(password: str) -> str:

    """
    Encrypts a password using a Caesar cipher with the key 11

    Args:
        password (str): The password to be encrypted

    Returns:
        str: Returns the encrypted password
    """

    key = generate_key()
    encrypted_password = ""

    for char in password:
        ascii = ord(char)
        char_encrypt = ascii + key
        if char_encrypt > 126:
            char_encrypt = 33 + char_encrypt - 127
        final_char = chr(char_encrypt)
        encrypted_password +=  final_char
    return encrypted_password


def string_to_user(input:str)-> tuple:
    
    """
    The input is a string which is then converted into a user's dictionary
    The password in the dictionary is the encrypted password

    Args:
        input (str): The input string in the format -> "user|password|bio|country|friend1,friend2,..."
    
    Returns: 
        tuple: where the first element is the user's name and the second element is the dictionary of the user's description 
    """

    seperation = input.split(' | ')

    desc = seperation[0]
    frnds = seperation[1]

    info = desc.split(', ')

    username = info[0].strip()
    password = info[1].strip()
    bio = info[2].strip()
    country = info[3].strip()
    friends = frnds.split(', ')
    encrypted_password = encrypt_password(password)

    user_dict = {
        "password": encrypted_password,
        "bio": bio,
        "country": country,
        "friends": friends
    }

    return username, user_dict


def initialize_social_network_from_file(filename:str)->dict|int:

    """
    Social network is initialized from a file where each line is a user's description
    Errors are returned if the user is already in the social network

    Args:
        filename (str): The name of the file where the users are stored
    
    Returns:
        dict: A dictionary where the keys are the usernames and the values are the user's dictionaries in the social network
        int: error code if the operation fails
    """

    social_network = {}
    file = open(filename, 'r') 
    lines = file.readlines()
    file.close()

    for line in lines:

        user_info = line.strip()
        if len(user_info) > 0:

            user_tuple = string_to_user(user_info)
            username = user_tuple[0]
            user_dict = user_tuple[1]

            if username in social_network:
                return ERROR_DUPLICATE_USER
            
            social_network[username] = user_dict

    return social_network


def authenticate_user(user_check:str, user_password_check:str,social_network:dict)->bool:

    """
    Authenticates a user by crosschecking the username and password with the social network
    It take the input password and encrypts it and then checks it with the encrypted password in the social network
    If the two match then it returns True and returns False if they dont match 

    Args:
        user_check (str): The username to check
        user_password_check (str): The password to check
        social_network (dict): The social network to check against

    Returns:
        bool: True if the user is authenticated, False otherwise
    """

    for user in social_network:
        if user == user_check:
            if social_network[user]['password'] == encrypt_password(user_password_check):
                return True
    
    return False


def add_friend(user1:str, password: str, user2:str, social_network:dict)-> None|int:
    
    """
    Adds a friend to a user in the social network by first authenticating the user, then checking if the friend is in the social network
    and then checks if the user2 is already a friend of user1

    Args:
        user1 (str): user to whom we need to add a friend to 
        user2 (str): user to be added as a friend
        password (str): password of user1 to be authenticated
        social_network (dict): The social network to check against

    Returns:
        None: If the friend is added successfully
        int: ERROR_USER_NOT_FOUND or ERROR_USER_ALREADY_FRIENDS if the friend is not added
    """

    if user1 != user2:

        if authenticate_user(user1, password, social_network):

            if user2 in social_network:

                for friend in social_network[user1]['friends']:

                    if friend == user2:
                        return ERROR_FRIEND_ALREADY_FOUND
                    
                social_network[user1]['friends'].append(user2)
                social_network[user2]['friends'].append(user1)
                return None
            else:
                return ERROR_USER_NOT_FOUND
        else:
            return ERROR_FAILED_AUTHENTICATION
    else:
        return None


def get_friend_index(user1: str, user2: str, social_network: dict)->int:
    
    """
    Gets the index of a friend in the friends list of a user in the social network

    Args:
        user1 (str): user to whom we need to get the index of a friend from
        user2 (str): user to be found in the friends list of user1
        social_network (dict): The social network to check against

    Returns:
        int: index of the friend in the friends list
    """

    if user1 in social_network:
        friends = social_network[user1]['friends']

        for i in range(len(friends)):

            if friends[i] == user2:
                return i
    return -1


def remove_friend(user1:str, password:str, user2:str, social_network:dict)->None|int:

    """
    Removes user2 from the user1's friends list and vice versa
    If user1 is not in the social network, it returns ERROR_USER_NOT_FOUND
    If user1 is not authenticated, it returns ERROR_FAILED_AUTHENTICATION
    If user2 is not in the friends list of user1, it returns ERROR_FRIEND_NOT_FOUND 

    Args:
        user1 (str): user to remove a friend from
        password (str): password of user1
        user2 (str): user to be removed from the friends list of user1
        social_network (dict): The social network to check against

    Returns:
        None: if the operation is successful
        int: error code if the operation fails
    """

    if authenticate_user(user1, password, social_network):

        if user1 in social_network:

            if user2 in social_network[user1]['friends']:
                index = get_friend_index(user1,user2,social_network)
                friends = social_network[user1]['friends']
                friends.pop(index)

                if user2 in social_network:
                    friends = social_network[user2]['friends']
                    index = get_friend_index(user2,user1,social_network)
                    friends.pop(index)

            else:
                return ERROR_FRIEND_NOT_FOUND 
        else:
            return ERROR_USER_NOT_FOUND
    else:
        return ERROR_FAILED_AUTHENTICATION


def num_countries_in_friends(user:str, password:str, social_network:dict)->int:

    """
    Returns the number of countries of the friends of user1 has
    If user1 is not in the social network, it returns ERROR_USER_NOT_FOUND
    If user1 is not authenticated, it returns ERROR_FAILED_AUTHENTICATION

    Args:
        user (str): The user to check against
        password (str): The password of the user
        social_network (dict): The social network to check against
    
    Returns:
        dict: A dictionary with the number of countries of each friend of user1
        int: error code if the operation fails
    """

    if authenticate_user(user, password, social_network):
        countries = {}
        if user in social_network:
            for friend in social_network[user]['friends']:
                country = social_network[friend]['country']
                if country not in countries:
                    countries[country] = 1
                else:
                    countries[country] += 1
            return countries
        else:
            return ERROR_USER_NOT_FOUND
    else:
        return ERROR_FAILED_AUTHENTICATION


def sort_friend_list(user: str, password: str, social_network: dict) -> None|int:
    """
    Sorts the friend list of user1 in alphabetical order
    The function uses Bubble Sort algorithm to sort the list. If two friends have the same number
    of friends in common, they remain in the same order as they appeared before the sort.

    Args:
    user (str): The user of the user.
    password (str): The password of the user.
    social_network (dict): The social network dictionary containing users and their information.
    
    Returns:
    None: This function mutates the friend's list in-place.
    """

    if not authenticate_user(user, password, social_network):
        return ERROR_FAILED_AUTHENTICATION
    
    if user not in social_network:
        return ERROR_USER_NOT_FOUND

    friends = social_network[user]['friends']
    n = len(friends)
    
    for i in range(n):
        for j in range(0, n-i-1):
            f_1 = friends[j]
            f_2 = friends[j+1]

            common_1 = get_common_friends(user, f_1, social_network)
            common_2 = get_common_friends(user, f_2, social_network)

            if common_1 < common_2:
                friends[j], friends[j+1] = friends[j+1], friends[j]





#HELPER FUNCTION
def get_common_friends(user: str, friend: str, social_network: dict) -> int:
    """
    Helper function that returns the number of common friends between the given user and friend.
    
    Args:
    user (str): The user of the user.
    friend (str): The friend's user.
    social_network (dict): The social network dictionary containing users and their information.
    
    Returns:
    int: The number of common friends.
    """
    social_network[friend].get('friends', []) == social_network[friend]['friends']
    user_friends = social_network[user]['friends']
    cf_count = 0
    
    for user_friend in user_friends:
        count = False
        for friend_friend in social_network[friend].get('friends', []):
            if user_friend == friend_friend:
                if not count:
                    cf_count += 1
                    count = True
    return cf_count

def get_level_friends(user:str, password:str, social_network:dict, level:int)-> list|int:
    
    """
    This functions returns a list of friends of the user at a certain level of friendship.
    It uses breadth-first search (BFS) to traverse the social network.

    Args:
        user (str): The user to check against
        password (str): The password of the user
        social_network (dict): The social network to check against
        level (int): The level of friendship to check against
    
    Returns:
        list[str]: A list of friends at the specified level of friendship
        int: error code if the operation fails
    """

    if authenticate_user(user, password, social_network):
        if user in social_network:
            queue = []
            distances = {}
            distances[user] = 0
            queue.append(user)
            
            while queue:
                current_user = queue.pop(0)
                
                for friend in social_network[current_user]['friends']:
                    if friend in distances:
                        if distances[friend] > (distances[current_user] + 1):
                            distances[friend] = distances[current_user] + 1
                    else:
                        queue.append(friend)
                        distances[friend] = distances[current_user] + 1
                    
                    level_friends = []
                    for user, dist in distances.items():
                        if dist == level:
                            level_friends.append(user)
            return level_friends
        
        else:
            return ERROR_FRIEND_NOT_FOUND
    else:
        return ERROR_FAILED_AUTHENTICATION



#- YOUR CODE ENDS HERE 
################################################################################

def social_network_application() -> None:
    """
        Social Network Interface for testing integration from all helper functions only
    """
    user_file_path = input("Enter users file path: ")
    
    # Initialize social network
    social_network = initialize_social_network_from_file(user_file_path)
    if (type(social_network) == int):
        print(error_to_string(social_network))
    
    # Flag to keep track of login status
    user_logged_in = False
    print("Welcome to the CMPSC 131 Social Network!")
    
    # Main loop for user logged in
    while not user_logged_in:
        
        # Login credentials input
        print("Please enter your login credentials:")
        username = input("Username: ")
        password = input("Password: ")
        
        # Authenticate the user.
        user_logged_in = authenticate_user(username, password, social_network)

        if not user_logged_in:
            print("Authentication failed. Incorrect username or password.")
        else:
            print("Login Successful")
            display_menu = True
            
            # Loop for the menu. If user is logged in, they can view the menu infinitely until they log out or exit the program.
            while display_menu:
                print("\n\nPlease select from the menu: ")
                print("1. Add Friend")    
                print("2. Remove Friend")
                print("3. Display Friend List (Sorted)")
                print("4. Display nth Level Friends")
                print("5. Display countries in your network")
                print("6. Log Out")
                print("7. Display menu")
                menu_option = input("Selection: ")


                if menu_option == '1':
                    friend_username = input("Friend Username: ")
                    ret = add_friend(username, password, friend_username, social_network)
                    if ret is None:
                        sort_friend_list(username, password, social_network)
                        print(f"Updated Friend List: {social_network[username]['friends']}")
                    else:
                        print(error_to_string(ret))
                elif menu_option == '2':
                    friend_username = input("Friend Username: ")
                    ret = remove_friend(username, password, friend_username, social_network)
                    if ret is None:
                        sort_friend_list(username, password, social_network)
                        print(f"Updated Friend List: {social_network[username]['friends']}")
                    else:
                        print(error_to_string(ret))
                elif menu_option == '3':
                    sort_friend_list(username, password, social_network)
                    print(f"Updated Friend List: {social_network[username]['friends']}")
                elif menu_option == '4':
                    level = int(input("Enter friendship level (1,2,3, etc.): "))
                    print(f"Your friends at level {level} are {get_level_friends(username, password, social_network, level)}")
                elif menu_option == '5':
                    print(f"Users per country in {username}'s network: \n {num_countries_in_friends(username, password, social_network)}")
                elif menu_option == '6':
                    # Exit display menu loop
                    display_menu = False
                    # Trigger the re-execution of the login loop
                    user_logged_in = False
                elif menu_option == '7':
                    print("Returning to main menu...")
                else:
                    print("Invalid Option. Returning to main menu...")
            
            print("Logging out...")

def main() -> None:
    # Start application
    pass
    social_network_application()
    

if __name__ == "__main__":
    main()
